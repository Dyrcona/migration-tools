#!/usr/bin/perl

use strict;
use warnings;

use Getopt::Long;
use Term::ReadLine;

my $term = new Term::ReadLine 'yaz-cleanup';
my $OUT = $term->OUT || \*STDOUT;

# initialization and setup
my $conf = {};
initialize($conf);
populate_trash() if ($conf->{trash});

my @record  = (); # current record storage
my %recmeta = (); # metadata about current record
my $ptr  = 0;  # record index pointer

my $input = shift || 'incoming.marc.xml';

open MARC, '<:utf8', $input;
open my $NUMARC, '>:utf8', $conf->{output};
print $NUMARC '<?xml version="1.0" encoding="UTF-8"?>',"\n";
print $NUMARC '<collection xmlns="http://www.loc.gov/MARC21/slim">',"\n";

open my $EXMARC, '>:utf8', $conf->{exception};

# this is the dispatch table which drives command selection in
# edit(), below
my %commands = ( c => \&print_context,
                 C => \&print_linecontext,
                 o => \&show_original,
                 O => \&insert_original,
                 f => \&flip_lines,
                 k => \&kill_line,
                 y => \&yank_line,
                 m => \&merge_lines,
                 n => \&next_line,
                 p => \&prev_line,
                 s => \&substitute,
                 t => \&commit_edit,
                 x => \&dump_record,
                 q => \&quit,
                 '?' => \&help,
                 h   => \&help,
                 help => \&help,
               );

my @spinner = qw(- / | \\);
my $sidx = 0;

while ( buildrecord() ) {
    unless ($conf->{ricount} % 100) {
        print "\rWorking... ", $spinner[$sidx];
        $sidx = ($sidx == $#spinner) ? 0 : $sidx + 1;
    }

    do_automated_cleanups();

    $ptr = 0;
    until ($ptr == $#record) {
        # naked ampersands
        if ($record[$ptr] =~ /&/ && $record[$ptr] !~ /&\w+?;/)
          { edit("Naked ampersand"); $ptr= 0; next }

        # tags must be numeric
        if ($record[$ptr] =~ /<datafield tag="(.+?)"/) {
            my $match = $1;
            if ($match =~ /\D/) {
                edit("Non-numerics in tag");
                $ptr = 0;
                next;
            }
        }

        # subfields can't be non-alphanumeric
        if ($record[$ptr] =~ /<subfield code="(.*?)"/) {
            my $match = $1;
            if ($match =~ /\P{IsAlnum}/ or $match eq '') {
                edit("Junk in subfield code/Null subfield code");
                $ptr = 0;
                next;
            }
        }
        $ptr++;
    }
    write_record($NUMARC);
}
print $NUMARC "</collection>\n";
print $OUT "\nDone.               \n";


#-----------------------------------------------------------------------------------
# cleanup routines
#-----------------------------------------------------------------------------------

sub do_automated_cleanups {
    $ptr = 0;
    until ($ptr == $#record) {
        # catch empty datafield elements
        if ($record[$ptr] =~ m/<datafield tag="..." ind1="." ind2=".">/) {
            if ($record[$ptr + 1] =~ m|</datafield>|) {
                my @a = @record[0 .. $ptr - 1];
                my @b = @record[$ptr + 2 .. $#record];
                @record = (@a, @b);
                message("Empty datafield scrubbed");
                $ptr = 0;
                next;
            }
        }
        # and quasi-empty subfields
        if ($record[$ptr] =~ m|<subfield code="(.*?)">(.*?)</sub|) {
            my $code = $1; my $content = $2;
            if ($code =~ /\W/ and ($content =~ /\s+/ or $content eq '')) {
                my @a = @record[0 .. $ptr - 1];
                my @b = @record[$ptr + 1 .. $#record];
                @record = (@a, @b);
                message("Empty subfield scrubbed");
                $ptr = 0;
                next;
            }
        }
        $ptr++;
    }

    # single-line fixes
    for $ptr (0 .. $#record) {
        # pad short leaders
        if ($record[$ptr] =~ m|<leader>(.+?)</leader>|) {
            my $leader = $1;
            if (length $leader < 24) {
                $leader .= ' ' x (20 - length($leader));
                $leader .= "4500";
                $record[$ptr] = "<leader>$leader</leader>\n";
                message("Short leader padded");
            }
        }
        if ($record[$ptr] =~ m|<controlfield tag="008">(.+?)</control|) {
            #pad short 008
            my $content = $1;
            if (length $content < 40) {
                $content .= ' ' x (40 - length($content));
                $record[$ptr] = "<controlfield tag=\"008\">$content</controlfield>\n";
                message("Short 008 padded");
            }
        }

        # clean misplaced dollarsigns
        if ($record[$ptr] =~ m|<subfield code="\$">c?\d+\.\d{2}|) {
            $record[$ptr] =~ s|"\$">c?(\d+\.\d{2})|"c">\$$1|;
            message("Dollar sign corrected");
        }

        # clean up tags with spaces in them
        $record[$ptr] =~ s/tag="  /tag="00/g;
        $record[$ptr] =~ s/tag=" /tag="0/g;
        $record[$ptr] =~ s/tag="-/tag="0/g;
        $record[$ptr] =~ s/tag="(\d\d) /tag="0$1/g;

        # stow tag data if we're looking at it
        if ($record[$ptr] =~ m/<datafield tag="(.{3})" ind1="(.)" ind2="(.)">/) {
            $recmeta{tag}  = $1;
            $recmeta{ind1} = $2;
            $recmeta{ind2} = $3;
        }

        # automatable subfield maladies
        $record[$ptr] =~ s/code=" ">c/code="c">/;
        $record[$ptr] =~ s/code=" ">\$/code="c"$>/;
    }
}

#-----------------------------------------------------------------------------------
# driver routines
#-----------------------------------------------------------------------------------


=head2 edit

Handles the Term::ReadLine loop

=cut

sub edit {
    my ($msg) = @_;

    return if $conf->{trash}{ $recmeta{tag} };
    message($msg, 1);
    print_context();

    # stow original problem line
    $conf->{origline} = $record[$ptr];

    while (1) {
        my $line = $term->readline('marc-cleanup>');
        my @chunks = split /\s+/, $line;

        if (length $chunks[0] == 1)
          { next unless (defined $commands{$chunks[0]}) }

        if (defined $commands{$chunks[0]}) {
            my $term = $commands{$chunks[0]}->(@chunks[1..$#chunks]);
            last if $term;
        } else {
            $record[$ptr] = "$line\n";
            print_linecontext();
        }
    }
}

=head2 buildrecord

Constructs record arrays from the incoming MARC file and returns them
to the driver loop.

=cut

sub buildrecord {
    my $l = '';
    $l = <MARC> while (defined $l and $l !~ /<record>/);
    return $l unless defined $l;
    @record = ($l);
    %recmeta = ();
    $conf->{ricount}++;

    until ($l =~ m|</record>|) 
      { push @record, $l; $l = <MARC>; }
    push @record, $l;
    return 1;
}

sub write_record {
    my ($FH) = @_;
    my $trash = $conf->{trash};

    $conf->{rocount}++ if ($FH eq $NUMARC);
    print $FH '<!-- ', $recmeta{explanation}, " -->\n"
      if(defined $recmeta{explanation});

    # excise unwanted tags
    if (keys %{$trash} or $conf->{autoscrub}) {
        my @trimmed = ();
        my $istrash = 0;
        for my $line (@record) {
            if ($istrash) {
                $istrash = 0 if $line =~ m|</datafield|;
                next;
            }
            if ($line =~ m/<datafield tag="(.{3})"/) {
                my $tag = $1;
                if ($trash->{$tag} or ($conf->{autoscrub} and $tag =~ /\D/)) {
                    $istrash = 1;
                    next
                }
            }
            push @trimmed, $line;
        }
        @record = @trimmed;
    }

    # scrub newlines
    unless ($conf->{nocollapse}) {
        s/\n// for (@record);
    }

    # add 903(?) with new record id
    my $renumber = '';
    if ($conf->{'renumber-from'}) {
        $renumber = join('', '<datafield tag="', $conf->{'renumber-tag'},
                         '" ind1=" " ind2=" ">',
                         '<subfield code="', $conf->{'renumber-subfield'}, '">',
                         $conf->{'renumber-from'}, '</subfield></datafield>');
        $renumber .= "\n" if $conf->{nocollapse};
        push @record, $renumber;
        $conf->{'renumber-from'}++;
    }

    print $FH @record;
    print $FH "</record>\n";
}

sub print_context {
    print "    Tag:",$recmeta{tag}, " Ind1:'",
      $recmeta{ind1},"' Ind2:'", $recmeta{ind2}, "'\n";
    print_linecontext();
    return 0;
}

sub print_linecontext {
    my $low = ($ptr - 3 < 0) ? 0 : $ptr - 3;
    print $OUT '    |', $record[$_] for ($low .. $ptr - 1);
    print $OUT '==> |', $record[$ptr];
    print $OUT '    |', $record[$ptr + 1], "\n";
    return 0;
}

sub message {
    my ($msg, $new) = @_;
    print $OUT "\r", ' ' x 72, "\n" if $new;
    print $OUT "\r$msg at ",$conf->{ricount},"/",$conf->{rocount} + 1,"\n";

}

#-----------------------------------------------------------------------------------
# command routines
#-----------------------------------------------------------------------------------

sub substitute {
    my ($line_in, @chunks) = @_;

    my $ofrom = shift @chunks;
    if ($ofrom =~ /^'/ or !@chunks) {
        until ($ofrom =~ /'$/)
          { $ofrom .= join(' ','',shift @chunks) }
        $ofrom =~ s/^'//; $ofrom =~ s/'$//;
    }
    my $to = shift @chunks;
    if ($to =~ /^'/) {
        until ($to =~ /'$/ or !@chunks)
          { $to .= join(' ','',shift @chunks) }
        $to =~ s/^'//; $to =~ s/'$//;
    }

    my $from = '';
    for my $char (split(//,$ofrom)) {
        $char = "\\" . $char if ($char =~ /\W/);
        $from = join('', $from, $char);
    }

    $conf->{prevline} = $record[$ptr];
    $record[$ptr] =~ s/$from/$to/;
    print_linecontext();
    return 0;
}

sub merge_lines {
    $conf->{prevline} = $record[$ptr];
    # remove <subfield stuff; extract (probably wrong) subfield code
    $record[$ptr] =~ s/^\s*<subfield code="(.*?)">//;
    # and move to front of line
    $record[$ptr] = join(' ', $1 , $record[$ptr]);
    # tear off trailing subfield tag from preceeding line
    $record[$ptr - 1] =~ s|</subfield>\n||;
    # join current line onto preceeding line
    $record[$ptr - 1] = join('', $record[$ptr - 1], $record[$ptr]);
    # erase current line
    my @a = @record[0 .. $ptr - 1];
    my @b = @record[$ptr + 1 .. $#record];
    @record = (@a, @b);
    # move record pointer to previous line
    prev_line();
    print_linecontext();
    return 0;
}

sub flip_line {
    my $temp = $record[$ptr];
    $record[$ptr] = $conf->{prevline};
    $conf->{prevline} = $temp;
    print_linecontext();
    return 0;
}

sub kill_line {
    $conf->{prevline} = $record[$ptr];
    my @a = @record[0 .. $ptr - 1];
    my @b = @record[$ptr + 1 .. $#record];
    @record = (@a, @b);
    print_linecontext();
    return 0;
}

sub yank_line {
    my @a = @record[0 .. $ptr - 1];
    my @b = @record[$ptr .. $#record];
    @record = (@a, $conf->{prevline}, @b);
    print_linecontext();
    return 0;
}

sub show_original {
    my ($line_in) = @_;
    print $OUT "\n", $conf->{origline}, "\n";
    return 0;
}

sub dump_record {
    my ($line_in, @explanation) = @_;
    $recmeta{explanation} = join(' ', 'Tag', $recmeta{tag}, @explanation);
    write_record($EXMARC);
    return 1;
}

sub next_line {
    $ptr++;
    print_linecontext();
    return 0;
}

sub prev_line {
    $ptr--;
    print_linecontext();
    return 0;
}

sub commit_edit { return 1 }

sub help {
print $OUT <<HELP;

Type a replacement for the indicated line, or enter a command.

Commands: c  Show record context again ('C' for brief context)
          k  Kill indicated line (remove from record)
          m  Merge indicated line with previous line
          o  Show original line
          s  Substitute ARG1 for ARG2 in indicated line
          t  Commit changes and resume stream edit
          x  Write this record to the exception file instead of output
          q  Quit

HELP
return 0;
}

sub quit { exit }

#-----------------------------------------------------------------------------------
# populate_trash
#-----------------------------------------------------------------------------------
# defined a domain-specific language for specifying MARC tags to be dropped from
# records during processing. it is line oriented, and is specified as follows:
#
# each line may specify any number of tags to be included, either singly (\d{1,3})
# or as a range (\d{1,3}\.\.\d{1,3}
#
# if a single number is given, it must be between '000' and '999', inclusive.
#
# ranges obey the previous rule, and also the first number of the range must be less
# than the second number
#
# finally, any single range in a line may be followed by the keyword 'except'. every
# number or range after 'except' is excluded from the range specified. all these
# numbers must actually be within the range.
#
# specifying a tag twice is an error, to help prevent typos

sub populate_trash {
    print $OUT ">>> TRASHTAGS FILE FOUND. LOADING TAGS TO BE STRIPPED FROM OUTPUT\n";
    open TRASH, '<', $conf->{trash}
      or die "Can't open trash tags file!\n";
    while (<TRASH>) {
        my $lastwasrange = 0;
        my %lastrange = ( high => 0, low => 0);
        my $except = 0;

        my @chunks = split /\s+/;
        while (my $chunk = shift @chunks) {

            # single values
            if ($chunk =~ /^\d{1,3}$/) {
                trash_add($chunk, $except);
                $lastwasrange = 0;
                next;
            }

            # ranges
            if ($chunk =~ /^\d{1,3}\.\.\d{1,3}$/) {
                my ($low, $high) = trash_add_range($chunk, $except, \%lastrange);
                $lastwasrange = 1;
                %lastrange = (low => $low, high => $high)
                  unless $except;
                next;
            }

            # 'except'
            if ($chunk eq 'except') {
                die "Keyword 'except' can only follow a range (line $.)\n"
                  unless $lastwasrange;
                die "Keyword 'except' may only occur once per line (line $.)\n"
                  if $except;
                $except = 1;
                next;
            }

            die "Unknown chunk $chunk in .trashtags file (line $.)\n";
        }
    }

    # remove original id sequence tag from trash hash if we know it
    trash_add($conf->{'original-tag'}, 1)
      if ($conf->{'original-tag'} and $conf->{trash}{ $conf->{'original-tag'} });
}

sub trash_add_range {
    my ($chunk, $except, $range) = @_;
    my ($low,$high) = split /\.\./, $chunk;
    die "Ranges must be 'low..high' ($low is greater than $high on line $.)\n"
      if ($low > $high);
    if ($except) {
        die "Exception ranges must be within last addition range (line $.)\n"
          if ($low < $range->{low} or $high > $range->{high});
    }
    for my $tag ($low..$high) {
        trash_add($tag, $except)
    }
    return $low, $high;
}

sub trash_add {
    my ($tag, $except) = @_;
    my $trash = $conf->{trash};

    die "Trash values must be valid tags (000-999)\n"
      unless ($tag >= 0 and $tag <= 999);

    if ($except) {
        delete $trash->{$tag};
    } else {
        die "Trash tag '$tag' specified twice (line $.)\n"
          if $trash->{$tag};
        $trash->{$tag} = 1;
    }
}

#-----------------------------------------------------------------------

=head2 initialize

Performs boring script initialization. Handles argument parsing,
mostly.

=cut

sub initialize {
    my ($c) = @_;
    my @missing = ();

    # set mode on existing filehandles
    binmode(STDIN, ':utf8');

    my $rc = GetOptions( $c,
                         'autoscrub|a',
                         'exception|x=s',
                         'output|o=s',
                         'nocollapse|n',
                         'renumber-from|rf=i',
                         'original-tag|ot=i',
                         'renumber-tag|rt=i',
                         'renumber-subfield|rt=i',
                         'trash|t=s',
                         'help|h',
                       );
    show_help() unless $rc;
    show_help() if ($c->{help});

    # defaults
    $c->{output} = 'incoming.cleaned.marc.xml' unless defined $c->{output};
    $c->{exception} = 'incoming.exception.marc.xml' unless defined $c->{exception};
    $c->{'renumber-tag'} = 903 unless defined $c->{'renumber-tag'};
    $c->{'renumber-subfield'} = 'a' unless defined $c->{'renumber-subfield'};

    my @keys = keys %{$c};
    show_help() unless (@ARGV and @keys);
    #for my $key ('runtype', 'tag', 'subfield', 'output', 'exception')
    #  { push @missing, $key unless $c->{$key} }
    #if (@missing) {
    #    print "Required option: ", join(', ', @missing), " missing!\n";
    #    show_help();
    #}
}

sub show_help {
    print <<HELP;
Usage is: $0 [OPTIONS] <filelist>
Options
  --output     -o  Cleaned MARCXML output filename (default: incoming.cleaned.marc.xml)
  --exception  -x  Exception (dumped records) MARCXML filename (incoming.exception.marc.xml)
HELP
exit;
}
