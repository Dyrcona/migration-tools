#!/usr/bin/perl
use strict;
use warnings;
use open ':utf8';

use Digest::SHA1 qw(sha1_base64);
use Getopt::Long;

my $conf  = {}; # configuration hashref
initialize($conf);

my %fps  = (); # records matching each fingerprint (and the lead)
my %recs = (); # fingerprints belonging to each record

open FP, '<', $ARGV[0] or die "Can't open input file: $!\n";

my $count = 0;
my $i = 0;
my $total = `wc -l $ARGV[0]`;
$| = 1;

print "Loading and ranking fingerprints\n";
while (<FP>) {
    my @fields = split "\t", $_;
    my $fp = populate_fingerprint(@fields);
    rank_fingerprint($fp);
    $i++;
    print "\r", ( int($i / $total) ), "% complete" unless ($i % 1000);
}
print "$total fingerprints processed\n";
print "$count records set as leads\n";
print "Writing matchset to disk\n";
dump_records();



sub populate_fingerprint {
    my @fields = @_;
    my %fp = (); # zero fingerprint hash each time thru

    # populate fp hash -- first the simple data
    $fp{compact} = shift @fields;
    $fp{json}    = shift @fields;
    $fp{id}      = shift @fields;
    # then smash everything else together, remove non-Roman characters, and
    # generate a SHA1 hash to represent it
    my $stripped = join('', @fields);
    $stripped   =~ s/[^A-Za-z0-9]//g;
    $fp{sha1}    = sha1_base64($stripped);

    # populate records hash
    $recs{ $fp{id} }{ $fp{sha1} } = {};

    return \%fp;
}


sub rank_fingerprint {
    my ($fp) = @_;

    my $sha1 = $fp->{sha1};
    my $id   = $fp->{id};
    my $islead = $recs{$id}{lead};

    # only process records which haven't already been set as a sub
    unless (defined $islead and $islead) {
        unless ($fps{$sha1}) {
            # haven't seen this fp before. create a new hashref with the current
            # record as lead
            $fps{$sha1} = { lead => { id    => $id,
                                      score => $fp->{compact} },
                            recs => [ $id ] };
            $recs{$id}{lead} = 1;
            $count++;
        } else {
            # have seen this fp. push record id onto matchlist
            push @{ $fps{$sha1}{recs} }, $id;
            if ($fp->{compact} > $fps{$sha1}{lead}{score}) {
                # and set this record as lead if it scores higher than current lead
                $recs{ $fps{$sha1}{lead}{id} }{lead} = 0; # unset current
                $recs{ $id }{lead} = 1;                   # set new as lead
                $fps{$sha1}{lead}{id}    = $id;
                $fps{$sha1}{lead}{score} = $fp->{compact};
            }
        }
    }
}


=head2 dump_records

Writes out a 2-column file of lead and subordinate records.

=cut

sub dump_records {
    my %used = ();
    open OUT, '>', $conf->{output}
      or die "Can't open ", $conf->{output}, "$!\n";
    for my $id (keys %recs) {
        next unless $recs{$id}{lead};
        for my $sha1 ( keys %{$recs{$id}} ) {
            for my $subid ( @{$fps{$sha1}{recs}} ) {
                next if ($id == $subid);
                next if defined $used{$subid};
                $used{$subid} = 1;
                print OUT "$id\t$subid\n";
            }
        }
    }
}

sub initialize {
    my ($c) = @_;
    my @missing = ();

    # set mode on existing filehandles
    binmode(STDIN, ':utf8');

    my $rc = GetOptions( $c,
                         'output|o=s',
                         'help|h',
                       );
    show_help() unless $rc;
    show_help() if ($c->{help});

    my @keys = keys %{$c};
    show_help() unless (@ARGV and @keys);
    for my $key ('output')
      { push @missing, $key unless $c->{$key} }
    if (@missing) {
        print "Required option: ", join(', ', @missing), " missing!\n";
        show_help();
    }
}

sub show_help {
    print <<HELP;
Usage is: compress_fingerprints -o OUTPUTFILE INPUTFILE
HELP
exit;
}
