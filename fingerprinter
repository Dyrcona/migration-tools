#!/usr/bin/perl
use strict;
use warnings;
use open ':utf8';

use Getopt::Long;
use MARC::Batch;
use Unicode::Normalize;
use MARC::File::XML ( BinaryEncoding => 'utf-8' );

my $conf  = {}; # configuration hashref
my $count = 0; my $scount = 0;
my $start = time;
$| = 1;

initialize($conf);

open OF, '>', $conf->{output};
open XF, '>', $conf->{exception};

for my $file (@ARGV) {
    print XF "Processing $file\n";
    my $batch = undef; my $record = undef;

    $batch = MARC::Batch->new($conf->{marctype}, $file);
    $batch->strict_off();
    $batch->warnings_off();

    while ( $record = $batch->next ) {
        $count++; progress_ticker();
        my $marc = undef;
        unless ( defined $record )
          { dump_exception($marc); next; }

        my $id = $record->field($conf->{tag});
        unless ($id) {
            print XF "ERROR: Record $count in $file is missing a ",
              $conf->{tag}, " field.\n", $record->as_formatted(), "\n=====\n";
            next;
        }

        # populate and normalize marc
        $marc = populate_marc($record, $id);
        normalize_marc($marc);
        unless (marc_isvalid($marc))
          { dump_exception($marc); next; }

        # if everything looks good, score it and dump fingerprints
        score_marc($marc, $record);
        dump_fingerprints($marc);
        $scount++; progress_ticker();
    }
}

print "\nSuccessfully processed:\t$count\n" unless $conf->{quiet};

=head2 populate_marc

Constructs a hash containing the relevant MARC data for a record and
returns a reference to it.

=cut

sub populate_marc {
    my ($record, $id) = @_;
    my %marc = (); $marc{isbns} = [];

    # id, stringified
    $marc{id} = $id->as_string($conf->{subfield});

    # record_type, bib_lvl
    $marc{record_type} = substr($record->leader, 6, 1);
    $marc{bib_lvl}     = substr($record->leader, 7, 1);

    # date1, date2
    my $my_008 = $record->field('008');
    $my_008 = $my_008->as_string() if ($my_008);
    if (defined $my_008) {
        unless (length $my_008 == 40) {
            $my_008 = $my_008 . (' ' x (40 - length($my_008)));
            print XF ">> Short 008 padded to ",length($my_008)," at rec $count\n";
        }
        $marc{date1} = substr($my_008,7,4) if ($my_008);
        $marc{date2} = substr($my_008,11,4) if ($my_008); # UNUSED
    }
    unless ($marc{date1} and $marc{date1} =~ /\d{4}/) {
        my $my_260 = $record->field('260');
        my $date1 = $my_260->subfield('c') if $my_260;
        if (defined $date1 and $date1 =~ /\d{4}/) {
            $marc{date1} = $date1;
            print XF ">> using 260c as date1 at rec $count\n";
        }
    }

    # item_form
    if ( $marc{record_type} =~ /[gkroef]/ ) { # MAP, VIS
        $marc{item_form} = substr($my_008,29,1) if ($my_008);
    } else {
        $marc{item_form} = substr($my_008,23,1) if ($my_008);
    }

    # isbns
    my @isbns = $record->field('020') if $record->field('020');
    push @isbns, $record->field('024') if $record->field('024');
    for my $f ( @isbns ) {
        push @{ $marc{isbns} }, $1 if ( defined $f->subfield('a') and
                                        $f->subfield('a')=~/(\S+)/ );
    }

    # author
    for my $rec_field (100, 110, 111) {
        if ($record->field($rec_field)) {
            $marc{author} = $record->field($rec_field)->subfield('a');
            last;
        }
    }

    # oclc
    $marc{oclc} = [];
    push @{ $marc{oclc} }, $record->field('001')->as_string()
      if ($record->field('001') and $record->field('003') and
          $record->field('003')->as_string() =~ /OCo{0,1}LC/);
    for ($record->field('035')) {
        my $oclc = $_->subfield('a');
        push @{ $marc{oclc} }, $oclc
          if (defined $oclc and $oclc =~ /\(OCoLC\)/ and $oclc =~/([0-9]+)/);
    }

    # "Accompanying material" (300e)
    $marc{accomp} = $record->field('300')->subfield('e')
      if $record->field('300');

    # issn, lccn, title, desc, pages, pub, pubyear, edition
    $marc{lccn} = $record->field('010')->subfield('a') if $record->field('010');
    $marc{issn} = $record->field('022')->subfield('a') if $record->field('022');
    $marc{desc} = $record->field('300')->subfield('a') if $record->field('300');
    $marc{pages} = $1 if (defined $marc{desc} and $marc{desc} =~ /(\d+)/);
    $marc{title} = $record->field('245')->subfield('a')
      if $record->field('245');
    $marc{edition} = $record->field('250')->subfield('a')
      if $record->field('250');
    if ($record->field('260')) {
        $marc{publisher} = $record->field('260')->subfield('b');
        $marc{pubyear} = $record->field('260')->subfield('c');
        $marc{pubyear} =
          (defined $marc{pubyear} and $marc{pubyear} =~ /(\d{4})/) ? $1 : '';
    }
    return \%marc;
}



=head2 normalize_marc

Gently massages your data.

=cut

sub normalize_marc {
    my ($marc) = @_;

    $marc->{record_type }= 'a' if ($marc->{record_type} eq ' ');
    if ($marc->{title}) {
        $marc->{title} = NFD($marc->{title});
        $marc->{title} =~ s/[\x{80}-\x{ffff}]//go;
        $marc->{title} = lc($marc->{title});
        $marc->{title} =~ s/\W+$//go;
    }
    if ($marc->{author}) {
        $marc->{author} = NFD($marc->{author});
        $marc->{author} =~ s/[\x{80}-\x{ffff}]//go;
        $marc->{author} = lc($marc->{author});
        $marc->{author} =~ s/\W+$//go;
        if ($marc->{author} =~ /^(\w+)/) {
            $marc->{author} = $1;
        }
    }
    if ($marc->{publisher}) {
        $marc->{publisher} = NFD($marc->{publisher});
        $marc->{publisher} =~ s/[\x{80}-\x{ffff}]//go;
        $marc->{publisher} = lc($marc->{publisher});
        $marc->{publisher} =~ s/\W+$//go;
        if ($marc->{publisher} =~ /^(\w+)/) {
            $marc->{publisher} = $1;
        }
    }
    return $marc;
}



=head2 marc_isvalid

Checks MARC record to see if neccessary fingerprinting data is
available

=cut

sub marc_isvalid {
    my ($marc) = @_;
    return 1 if ($marc->{item_form} and ($marc->{date1} =~ /\d{4}/) and
                 $marc->{record_type} and $marc->{bib_lvl} and $marc->{title});
    return 0;
}


=head2 score_marc

Assign a score to the record based on various criteria.

Score is constructed by pushing elements onto a list. At the end of
the routine, the list is flattened into a string via join();

=cut

sub score_marc {
    my ($marc, $record) = @_;
    my @score = ();
    my $chunk;

    # Is this an OCLC record?
    if ($conf->{scores}{oclc})
      { push @score, ( defined $marc->{oclc}[0] ? 1 : 0 ) }

    # does 040a contain "dlc"?
    if ($conf->{scores}{dlc}) {
        if ($record->field('040') and $record->field('040')->subfield('a')) {
            $chunk = $record->field('040')->subfield('a');
            push @score, ( $chunk =~ /dlc/i ? 1 : 0 );
        } else {
            push @score, 0;
        }
    }

    # number of 650 datafields
    # zero-padded to 4 digits with printf
    if ($conf->{scores}{num_650}) {
        if ($record->field('650')) {
            my @tags = $record->field('650');
            push @score, ( sprintf("%04d", scalar @tags) );
        } else {
            push @score, '0000';
        }
    }

    # number of tags in total
    # zero-padded to 4 digits with printf
    if ($conf->{scores}{num_tags}) {
        my @tags = $record->fields;
        push @score, ( sprintf("%04d", scalar @tags) );
    }

    # encoding level
    if ($conf->{scores}{enc_lvl}) {
        my $enc = substr($record->leader, 17, 1);
        my %levels = ( ' ' => 9, 1 => 8, 2 => 7,  3  => 6,  4  => 5, 5 => 4,
                       6   => 3, 7 => 2, 8 => 1, 'u' => 0, 'z' => 0 );
        if (defined $enc and $levels{$enc})
          { push @score, $levels{$enc} }
        else
          { push @score, 0 }
    }

    # put score in marc hash
    $marc->{score} = join('', '{oclc:', $score[0], ',dlc:', $score[1],
                          ',num_650:', $score[2], ',num_tags:', $score[3],
                          ',enc_lvl:', $score[4], '}');
}

=head2 dump_fingerprints

=cut

sub dump_fingerprints {
    my ($marc) = @_;

    if ($conf->{fingerprints}{baseline}) {
        print OF join("\t", $marc->{score}, $marc->{id}, 'baseline',
                      $marc->{item_form}, $marc->{date1}, $marc->{record_type},
                      $marc->{bib_lvl}, $marc->{title}), "\n";
    }

    if ($conf->{fingerprints}{oclc} and scalar @{$marc->{oclc} }) {
        for (@{$marc->{oclc} }) {
            print OF join("\t", $marc->{score}, $marc->{id}, "oclc",
                          $marc->{item_form}, $marc->{date1},
                          $marc->{record_type}, $marc->{bib_lvl},
                          $marc->{title}, $_, "\n");
        }
    }

    if ($conf->{fingerprints}{isbn}) {
        if ((scalar @{ $marc->{isbns} } > 0) and $marc->{pages}) {
            foreach my $isbn ( @{ $marc->{isbns}} ) {
                print OF join("\t", $marc->{score}, $marc->{id}, "isbn",
                              $marc->{item_form}, $marc->{date1},
                              $marc->{record_type},
                              $marc->{bib_lvl}, $marc->{title},
                              $isbn, $marc->{pages}), "\n";
            }
        }
    }

    if ($conf->{fingerprints}{edition} and $marc->{edition}) {
        print OF join("\t", $marc->{score}, $marc->{id}, "edition",
                      $marc->{item_form}, $marc->{date1},
                      $marc->{record_type}, $marc->{bib_lvl},
                      $marc->{title}, $marc->{edition}), "\n";
    }

    if ($conf->{fingerprints}{issn} and $marc->{issn}) {
        print OF join("\t", $marc->{score}, $marc->{id}, "issn",
                      $marc->{item_form}, $marc->{date1},
                      $marc->{record_type}, $marc->{bib_lvl},
                      $marc->{title}, $marc->{issn}), "\n";
    }

    if ($conf->{fingerprints}{lccn} and $marc->{lccn}) {
        print OF join("\t", $marc->{score}, $marc->{id}, "lccn",
                      $marc->{item_form}, $marc->{date1},
                      $marc->{record_type}, $marc->{bib_lvl},
                      $marc->{title}, $marc->{lccn}) ,"\n";
    }

    if ($conf->{fingerprints}{accomp} and $marc->{accomp}) {
        print OF join("\t", $marc->{score}, $marc->{id}, "accomp",
                      $marc->{item_form}, $marc->{date1},
                      $marc->{record_type}, $marc->{bib_lvl},
                      $marc->{title}, $marc->{accomp}) ,"\n";
    }

    if ($conf->{fingerprints}{authpub} and $marc->{author} and
        $marc->{publisher} and $marc->{pubyear} and $marc->{pages}) {
        print OF join("\t", $marc->{score}, $marc->{id}, "authpub",
                      $marc->{item_form}, $marc->{date1},
                      $marc->{record_type}, $marc->{bib_lvl},
                      $marc->{title}, $marc->{author},
                      $marc->{publisher}, $marc->{pubyear},
                      $marc->{pages}), "\n";
    }
}



=head2 dump_exception

Write line of exception report

=cut

sub dump_exception {
    my ($marc) = @_;
    unless (defined $marc) {
        print XF "Undefined record at line $count; likely bad XML\n";
        return;
    }
    print XF "Record ", $marc->{id}, " did not make the cut: ";
    print XF "Missing item_form. " unless ($marc->{item_form});
    unless (defined $marc->{date1})
      { print XF "Missing date1. " }
    else
      { print XF "Invalid date1: ", $marc->{date1}, " "
          unless ($marc->{date1} =~ /\d{4}/); }
    print XF "Missing record_type. " unless ($marc->{record_type});
    print XF "Missing bib_lvl. " unless ($marc->{bib_lvl});
    print XF "Missing title. " unless ($marc->{title});
    print XF "\n";
}


=head2 initialize

Performs boring script initialization. Handles argument parsing,
mostly.

=cut

sub initialize {
    my ($c) = @_;
    my @missing = ();

    # set mode on existing filehandles
    binmode(STDIN, ':utf8');

    my $rc = GetOptions( $c,
                         'incoming',
                         'incumbent',
                         'exception|x=s',
                         'marctype|m=s',
                         'output|o=s',
                         'runtype|r=s',
                         'subfield|s=s',
                         'tag|t=s',
                         'fingerprints=s',
                         'scores=s',
                         'quiet|q',
                         'help|h',
                       );
    show_help() unless $rc;
    show_help() if ($c->{help});

    # check fingerprints list for validity
    if ($c->{fingerprints}) {
        my %fps = ();
        my %valid_fps = ( oclc => 1, isbn => 1, issn => 1, lccn => 1,
                          edition => 1, accomp => 1, authpub => 1,
                          baseline => 1, crap => 1,
                        );
        for (split /,/, $c->{fingerprints}) {
            die "Invalid fingerprint '$_'\n" unless $valid_fps{$_};
            $fps{$_} = 1;
        }
        $c->{fingerprints} = \%fps
    } else {
        $c->{fingerprints} = {oclc => 1, isbn => 1, edition => 1, issn => 1,
                              lccn => 1, accomp => 1, authpub => 1};
    }
    # check scores list for validity
    if ($c->{scores}) {
        my %scores = ();
        my %valid_scores = ( oclc => 1, dlc => 1, num_650 => 1,
                             num_tags => 1, enc_lvl => 1,
                           );
        for (split /,/, $c->{scores}) {
            die "Invalid score mode '$_'\n" unless $valid_scores{$_};
            $scores{$_} = 1;
        }
        $c->{scores} = \%scores;
    } else {
        $c->{scores} = {oclc => 1, dlc => 1, num_650 => 1,
                        num_tags => 1, enc_lvl => 1};
    }

    # set defaults if told to do so
    if ($c->{incoming}) {
        $c->{tag} = 903 unless defined $c->{tag};
        $c->{subfield} = 'a' unless defined $c->{subfield};
        $c->{marctype} = 'XML' unless defined $c->{marctype};
        $c->{output} = 'incoming.fp' unless defined $c->{output};
        $c->{exception} = 'incoming.ex' unless defined $c->{exception};
    } elsif ($c->{incumbent}) {
        $c->{tag} = 901 unless defined $c->{tag};
        $c->{subfield} = 'c' unless defined $c->{subfield};
        $c->{marctype} = 'XML' unless defined $c->{marctype};
        $c->{output} = 'incumbent.fp' unless defined $c->{output};
        $c->{exception} = 'incumbent.ex' unless defined $c->{exception};
    }

    my @keys = keys %{$c};
    show_help() unless (@ARGV and @keys);
    for my $key ('tag', 'subfield', 'output', 'exception')
      { push @missing, $key unless $c->{$key} }
    if (@missing) {
        print "Required option: ", join(', ', @missing), " missing!\n";
        show_help();
    }
}


=head2 progress_ticker

=cut

sub progress_ticker {
    return if $conf->{quiet};
    printf("\r> %d recs seen; %d processed", $count, $scount);
    printf(" (%d/s)", ($count / (time - $start + 1)))
      if ($count % 500 == 0);
}

=head2 show_help

Display usage message when things go wrong

=cut

sub show_help {
print <<HELP;
Usage is: $0 [REQUIRED ARGS] [OPTIONS] <filelist>
Req'd Arguments
  --tag=N                  -t  Which tag to use
  --subfield=X             -s  Which subfield to use
  --output=<file>          -o  Output filename
  --exceptions=<file>      -x  Exception report filename
Options
  --incoming   '-t 903 -s a -o incoming.fp -x incoming.ex'
  --incumbent  '-t 901 -s c -o incumbent.fp -x incumbent.ex'

  --fingerprints=LIST  Fingerprints to generate, comma separated
                       Default: oclc,isbn,edition,issn,lccn,accomp,authpub
                       Others:  baseline
  --scores=LIST  Scores to calculate, comma separated
                 Default: oclc,dlc,num_650,num_tags,enc_level
  --quiet    -q  Don't write status messages to STDOUT
HELP
exit 1;
}
