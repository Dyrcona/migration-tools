#!/usr/bin/perl
use strict;
use warnings;

use Getopt::Long;
use Equinox::Migration::MapDrivenMARCXMLProc;
use Equinox::Migration::MARCXMLSampler;

my $VERSION = '1.001';

=pod

TODO

  * Have detail mode report on number of subfields per datafield

=cut

my $c = initialize();
$| = 1;

# run samples if we've been asked for them
run_samples($c) if ($c->{sample} or $c->{samplemap} or $c->{samplestr});
extract_holdings($c) if ($c->{map});

#--------------------------

sub extract_holdings {
    my ($c) = @_;
    print "Parsing records for extraction... ";
    my $m = Equinox::Migration::MapDrivenMARCXMLProc->new( marcfile => $c->{marcfile},
                                                           mapfile  => $c->{map},
                                                           verbose  => 1,
                                                         );
    print "Writing holdings to output file(s)...\n";
    # open main holdings file
    open HOLDINGS, '>', ($c->{prefix} . "-HOLDINGS.pg");
    # open the files for multi mappings
    # FIXME make this actually key off multi fields
    open X, '>', ($c->{prefix} . "-HOLDINGS-privnotes.pg");
    open Z, '>', ($c->{prefix} . "-HOLDINGS-pubnotes.pg");
    select HOLDINGS;

    my $i = 0;
    for my $rec ( @{$m->{data}{recs}} ) {
        # for each holdings tag in the record...
        for my $holdidx ( @{$rec->{tmap}{ $c->{holdings} }} ) {
            my $tagid = $rec->{tags}[$holdidx]{tag};

            print STDOUT "\r$i";
            my @out = ();            # clear the output buffer
            push @out, $rec->{egid}; # slug in the egid first thing
            print "BEGIN;\n\n" unless $i;

            # grab the unary mappings and slug 'em in
            for my $sub ( sort keys %{$rec->{tags}[$holdidx]{uni}} ) {
                push @out, $rec->{tags}[$holdidx]{uni}{$sub};
                #print "l_", $m->name($tagid, $sub),"\t"
                #  unless $i;
                # FIXME column names should be made workable again
            }

            for my $x (@{$rec->{tags}[$holdidx]{multi}{x}} ) {
                print X $rec->{egid}, "\t",
                  $rec->{tags}[$holdidx]{uni}{ $c->{copyid} },
                    "\t$x\n";
            }
            for my $z (@{$rec->{tags}[$holdidx]{multi}{z}} ) {
                print Z $rec->{egid}, "\t",
                  $rec->{tags}[$holdidx]{uni}{ $c->{copyid} },
                    "\t$z\n";
            }


            # now get everything else in the mapping
            for my $othertag ( sort keys %{$rec->{tmap}} ) {
                next if $othertag eq $c->{holdings};  # ignoring the holdings, o'course
                my $idx = $rec->{tmap}{$othertag}[0]; # get index into tags struct
                for my $sub ( sort keys %{$rec->{tags}[$idx]{uni}} ) {
                    push @out, $rec->{tags}[$idx]{uni}{$sub};
                    print "l_", $m->name($rec->{tags}[$idx]{tag}, $sub), "\t"
                      unless $i;
                }
            }

            # and dump it
            print "\n" if ($i == 1);
            print join("\t", @out);
            print "\n";
        }
        $i++;
    }
    select STDOUT;
    print "\n";
}

#--------------------------

sub run_samples {
    my ($c) = @_;
    my $s;
    if ($c->{samplemap}) {
        $s = Equinox::Migration::MARCXMLSampler->new( marcfile => $c->{marcfile},
                                                      mapfile  => $c->{samplemap});
    } elsif ($c->{samplestr}) {
        $s = Equinox::Migration::MARCXMLSampler->new( marcfile  => $c->{marcfile},
                                                      mapstring => $c->{samplestr});
    } else {
        $s = Equinox::Migration::MARCXMLSampler->new( marcfile => $c->{marcfile} );
    }
    print "Parsing records for sampling... ";
    $s->parse_records;

    dump_sample_overview($c, $s) if $c->{sample};
    dump_sample_detail($c, $s) if ($c->{samplemap} or $c->{samplestr});
}

sub dump_sample_detail {
    my ($c, $s) = @_;
    my $tags = $s->{data}{samp};
    my $count = $s->{data}{rcnt};
    my $scnt  = $s->{data}{scnt};

    open DETAIL, '>', ($c->{prefix} . "-HOLDINGS-DETAIL.txt");
    select DETAIL;
    for my $tag (sort keys %{ $tags }) {
        print ">>>>> TAG $tag\n\n";
        for my $subkey (sort keys %{ $tags->{$tag} }) {
            my $sub = $tags->{$tag}{$subkey};
            print "|| $subkey | ", $sub->{value}, " | ", 
              $sub->{count}, "/", $sub->{tcnt}, " |  ||\n";
        }
        print "\n";
    }
    close DETAIL;
    open SCOUNT, '>', ($c->{prefix} . "-HOLDINGS-SUBCOUNTS.txt");
    select SCOUNT;
    for my $tag (sort keys %{ $scnt }) {
        print ">>>>> TAG $tag\n\n";
        for my $len (sort keys %{ $scnt->{$tag} }) 
          { print "|| $len | ", $scnt->{$tag}{$len}, " ||\n" }
        print "\n";
    }
    select STDOUT;
}

sub dump_sample_overview {
    my ($c, $s) = @_;
    my $tags = $s->{data}{tags};
    my $count = $s->{data}{rcnt};

    my @tagsbyname  = sort keys %{$tags};
    my @tagsbycount = reverse sort { $tags->{$a} <=> $tags->{$b} } keys %{$tags};

    open SAMPLE, '>', ($c->{prefix} . "-HOLDINGS-OVERVIEW.txt");
    select SAMPLE;
    print "SAMPLE REPORT FOR ", $c->{prefix},": $count records\n\n";
    print "FOUND TAGS (BY TAG)           FOUND TAGS (BY COUNT)\n";
    print "------------------------      --------------------------\n";
    for my $i (0 .. @tagsbyname - 1) {
        print $tagsbyname[$i], (" " x (14 - length $tags->{ $tagsbyname[$i] })),
          $tags->{ $tagsbyname[$i] };
        print " (", sprintf("%03d", int($tags->{ $tagsbyname[$i] } / $count * 100)), "%)";
        print "      ";
        print $tagsbycount[$i], (" " x (16 - length $tags->{ $tagsbycount[$i] })),
          $tags->{ $tagsbycount[$i] };
        print " (", sprintf("%03d", int($tags->{ $tagsbycount[$i] } / $count * 100)), "%)\n";
    }
    select STDOUT;
    print "\n";
    close SAMPLE;
}

#--------------------------

sub initialize {
    my $c = {};
    my @missing = ();

    # set mode on existing filehandles
    binmode(STDIN, ':utf8');

    my $rc = GetOptions( $c,
                         'sample|s',
                         'samplemap|sm=s',
                         'samplestr|ss=s',
                         'marcfile|m=s',
                         'map=s',
                         'holdings|h=i',
                         'copyid|c=s',
                         'prefix|p=s',
                         'version|v',
                         'help',
                       );
    show_help() unless $rc;
    show_help() if ($c->{help});
    show_help("Nothing to do!")
      unless ($c->{map} or $c->{sample} or $c->{samplemap} or $c->{samplestr});
    show_help("map, holdings, and copyid must be specified together!")
      if ($c->{map} and !($c->{holdings} and $c->{copyid}));
    show_version() if $c->{version};

    my @keys = keys %{$c};
    for my $key ('prefix', 'marcfile')
      { push @missing, $key unless $c->{$key} }
    if (@missing) {
        print "Required option: ", join(', ', @missing), " missing!\n";
        show_help();
    }

    return $c;
}

sub show_help {
    my ($msg) = @_;
    print "\nERROR - $msg\n" if $msg;
    print <<HELP;

Usage is: extract_holdings -p PREFIX -m MARCFILE [ARGUMENTS]

REQUIRED ARGUMENTS
  --prefix   -p  Prefix string for output filenames
  --marcfile -m  MARCXML to use as source data

SAMPLING ARGUMENTS
  --sample    -s   Generate a report of all tags in the MARC data
  --samplemap -sm  Specify a E::M::STL map file which will be used to generate
                   subfield breakdown reports about specific tags in the MARC
                   data
  --samplestr -ss  As above, but with a one-liner map specified on the command
                   line as a string (e.g. '-ss "852 999"')

  If --samplemap and --samplestr are both specified, --samplemap wins.

HOLDINGS EXTRACTION ARGUMENTS
  --map          E::M::SM map file which will be used to extract holdings data
                 from the input MARC file
  --holdings -h  Specifies actual holdings tag
  --copyid   -c  Specifies subfield of holdings with unique copy identifier

  Both these must be given together.
HELP
    exit;
}

sub show_version { print "extract_holdings v$VERSION\n"; exit }
